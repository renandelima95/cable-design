<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calculadora de Roteamento de Cabos - Wire Bundle</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f0f2f5;
            min-height: 100vh;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 20px 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }

        .header h1 {
            font-size: 1.8em;
            margin-bottom: 5px;
        }

        .header p {
            opacity: 0.9;
            font-size: 1em;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 20px;
        }

        .section {
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            overflow: hidden;
        }

        .section-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 25px;
            font-size: 1.3em;
            font-weight: 600;
        }

        .section-content {
            padding: 25px;
        }

        /* Editor Gr√°fico */
        .toolbar {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .tool-btn {
            padding: 10px 20px;
            border: 2px solid #e0e0e0;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            background: white;
            transition: all 0.3s;
        }

        .tool-btn:hover {
            border-color: #667eea;
            background: #f8f9fa;
        }

        .tool-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: #667eea;
        }

        #canvas {
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            background: white;
            cursor: crosshair;
            width: 100%;
            height: 500px;
        }

        .info-box {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #2196f3;
            font-size: 0.9em;
            color: #1565c0;
            margin-bottom: 20px;
        }

        /* Rotas */
        .routes-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }

        .input-group {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
        }

        .input-row {
            margin-bottom: 15px;
        }

        .input-row-2col {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            color: #555;
            font-weight: 500;
            font-size: 0.9em;
        }

        input, select {
            width: 100%;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 5px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            padding: 12px 25px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: all 0.3s;
            margin-right: 10px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            width: 100%;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
        }

        .btn-danger:hover {
            background: #c0392b;
        }

        .btn-success {
            background: #27ae60;
            color: white;
        }

        .btn-success:hover {
            background: #229954;
        }

        .route-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 4px solid #667eea;
        }

        .route-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-weight: 600;
            color: #2c3e50;
        }

        .route-info {
            font-size: 0.9em;
            color: #666;
            line-height: 1.6;
        }

        .path-display {
            background: white;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            font-family: monospace;
            color: #2c3e50;
            border: 1px dashed #667eea;
        }

        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: #999;
        }

        .auto-route-badge {
            display: inline-block;
            background: #27ae60;
            color: white;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 0.75em;
            margin-left: 5px;
        }

        /* Resultados */
        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .result-card {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid #667eea;
        }

        .result-title {
            font-size: 1.2em;
            font-weight: 600;
            color: #667eea;
            margin-bottom: 15px;
        }

        .result-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #dee2e6;
        }

        .result-item:last-child {
            border-bottom: none;
        }

        .result-total {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 2px solid #667eea;
            font-weight: 600;
            font-size: 1.1em;
            display: flex;
            justify-content: space-between;
            color: #667eea;
        }

        /* Wire Bundle */
        .bundle-item {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .bundle-header {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.2em;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .bundle-diameter {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 1em;
        }

        .bundle-content {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 20px;
            align-items: center;
        }

        .bundle-visual {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .bundle-canvas {
            border: 2px solid #e0e0e0;
            border-radius: 5px;
        }

        .bundle-details {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
        }

        .wire-list-item {
            padding: 8px 0;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .wire-list-item:last-child {
            border-bottom: none;
        }

        .wire-color-dot {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #333;
        }

        .margin-control {
            background: #fff3cd;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 4px solid #ffc107;
        }

        .margin-control label {
            color: #856404;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        /* Modal para edi√ß√£o */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }

        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 30px;
            border-radius: 10px;
            width: 90%;
            max-width: 600px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        .modal-header {
            font-size: 1.5em;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #667eea;
        }

        .modal-close {
            float: right;
            font-size: 28px;
            font-weight: bold;
            color: #999;
            cursor: pointer;
            line-height: 20px;
        }

        .modal-close:hover {
            color: #e74c3c;
        }

        .edit-btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.85em;
            margin-left: 5px;
        }

        .edit-btn:hover {
            background: #2980b9;
        }
    </style>
</head>
<body>
    <!-- Modal de Edi√ß√£o -->
    <div id="editModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="modal-close" onclick="closeEditModal()">&times;</span>
                Editar Rota
            </div>
            <div class="input-group">
                <div class="input-row">
                    <label for="editCableType">Tipo de Cabo</label>
                    <select id="editCableType">
                        <option value="">Selecione...</option>
                    </select>
                </div>
                <div class="input-row">
                    <label for="editQuantity">Quantidade de Vias</label>
                    <input type="number" id="editQuantity" min="1" value="1">
                </div>
                <div class="input-row-2col">
                    <div>
                        <label for="editOrigin">Origem</label>
                        <select id="editOrigin">
                            <option value="">Selecione...</option>
                        </select>
                    </div>
                    <div>
                        <label for="editDestination">Destino</label>
                        <select id="editDestination">
                            <option value="">Selecione...</option>
                        </select>
                    </div>
                </div>
                <button class="btn btn-primary" onclick="saveEditedRoute()">üíæ Salvar Altera√ß√µes</button>
            </div>
        </div>
    </div>
    <div class="header">
        <div style="display: flex; align-items: center; justify-content: center; gap: 30px; margin-bottom: 15px;">
            <img src="assets/images/ares_logo.jpg" alt="ARES Logo" style="height: 50px;">
            <div style="text-align: center;">
                <h1 style="margin: 0;">Cable Design Tool</h1>
                <p style="margin: 5px 0 0 0; font-size: 0.9em; opacity: 0.85;">Designed by System Engineering</p>
            </div>
        </div>
    </div>

    <div class="container">
        <!-- SE√á√ÉO 1: EDITOR GR√ÅFICO -->
        <div class="section">
            <div class="section-header">üé® Editor Gr√°fico de Topologia</div>
            <div class="section-content">
                <div class="info-box">
                    <strong>Como usar:</strong> 
                    1Ô∏è‚É£ Clique em "Adicionar N√≥" e clique no canvas para criar pontos | 
                    2Ô∏è‚É£ Clique em "Conectar" e clique em dois n√≥s para criar conex√£o | 
                    3Ô∏è‚É£ Modo "Selecionar" permite arrastar n√≥s | 
                    4Ô∏è‚É£ Duplo-clique em um n√≥ para delet√°-lo
                </div>
                
                <div class="toolbar">
                    <button class="tool-btn active" id="addNodeBtn" onclick="setMode('addNode')">‚ûï Adicionar N√≥</button>
                    <button class="tool-btn" id="connectBtn" onclick="setMode('connect')">üîó Conectar</button>
                    <button class="tool-btn" id="selectBtn" onclick="setMode('select')">üëÜ Selecionar</button>
                    <button class="btn btn-danger" onclick="clearCanvas()">üóëÔ∏è Limpar Canvas</button>
                </div>

                <canvas id="canvas"></canvas>
            </div>
        </div>

        <!-- SE√á√ÉO 2: DEFINIR ROTAS -->
        <div class="section">
            <div class="section-header">üõ§Ô∏è Definir Rotas de Cabos</div>
            <div class="section-content">
                <div class="routes-grid">
                    <!-- Inputs -->
                    <div>
                        <h3 style="color: #2c3e50; margin-bottom: 15px;">Adicionar Nova Rota</h3>
                        
                        <div class="margin-control">
                            <label for="marginInput">Margem de Seguran√ßa (%)</label>
                            <input type="number" id="marginInput" value="10" min="0" max="50" step="1">
                        </div>

                        <div class="input-group">
                            <div class="input-row">
                                <label for="cableType">Tipo de Cabo</label>
                                <select id="cableType">
                                    <option value="">Selecione...</option>
                                </select>
                            </div>

                            <div class="input-row">
                                <label for="quantity">Quantidade de Vias</label>
                                <input type="number" id="quantity" placeholder="1" min="1" value="1" step="1">
                            </div>

                            <div class="input-row-2col">
                                <div>
                                    <label for="origin">Origem</label>
                                    <select id="origin">
                                        <option value="">Selecione...</option>
                                    </select>
                                </div>
                                <div>
                                    <label for="destination">Destino</label>
                                    <select id="destination">
                                        <option value="">Selecione...</option>
                                    </select>
                                </div>
                            </div>

                            <button class="btn btn-primary" onclick="addRoute()">‚ûï Adicionar Rota (Auto-Roteamento)</button>
                        </div>
                    </div>

                    <!-- Rotas Definidas -->
                    <div>
                        <h3 style="color: #2c3e50; margin-bottom: 15px;">Rotas Definidas</h3>
                        <div id="routesList">
                            <div class="empty-state">
                                <p>Nenhuma rota definida</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- SE√á√ÉO 3: RESULTADOS -->
        <div class="section">
            <div class="section-header">üìä Comprimento Total por Tipo de Cabo</div>
            <div class="section-content">
                <div id="resultsContainer" class="results-grid">
                    <div class="empty-state">
                        <p>Adicione rotas para ver os resultados</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- SE√á√ÉO 4: WIRE BUNDLE POR RAMIFICA√á√ÉO -->
        <div class="section">
            <div class="section-header">üîÄ Wire Bundle por Ramifica√ß√£o</div>
            <div class="section-content">
                <div id="bundleContainer">
                    <div class="empty-state">
                        <p>Adicione rotas para ver os wire bundles</p>
                    </div>
                </div>

                <div class="action-buttons">
                    <button class="btn btn-success" onclick="exportResults()">üì• Exportar Resultados (CSV)</button>
                    <button class="btn btn-success" onclick="saveProject()">üíæ Salvar Projeto Completo</button>
                    <button class="btn btn-success" onclick="document.getElementById('loadProjectInput').click()">üìÇ Carregar Projeto</button>
                    <input type="file" id="loadProjectInput" accept=".json" style="display: none;" onchange="loadProject(event)">
                    <button class="btn btn-danger" onclick="clearAll()">üóëÔ∏è Limpar Todas as Rotas</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Base de dados de cabos do Excel
        const cableDatabase = [
            {name: "20#", diameter: 1.45, color: "#FF6B6B", awg: "20#"},
            {name: "22# SHD", diameter: 2.0574, color: "#4ECDC4", awg: "22#"},
            {name: "2x 22# SHD", diameter: 2.89, color: "#45B7D1", awg: "22#"},
            {name: "3x 22# SHD", diameter: 3.2258, color: "#FFA07A", awg: "22#"},
            {name: "4x 22#", diameter: 3.96, color: "#98D8C8", awg: "22#"},
            {name: "6x 22#", diameter: 4.166, color: "#F7DC6F", awg: "22#"},
            {name: "3x 22#", diameter: 2.69, color: "#BB8FCE", awg: "22#"},
            {name: "22#", diameter: 1.0897, color: "#85C1E2", awg: "22#"},
            {name: "24# SHD", diameter: 1.96, color: "#F8B739", awg: "24#"},
            {name: "24#", diameter: 0.96, color: "#52B788", awg: "24#"},
            {name: "26# SHD", diameter: 1.778, color: "#FF8FAB", awg: "26#"},
            {name: "26AWG", diameter: 1.6256, color: "#6A8CAF", awg: "26#"},
            {name: "2x 26#", diameter: 2.33, color: "#FFD93D", awg: "26#"},
            {name: "3x 26#", diameter: 2.5908, color: "#95E1D3", awg: "26#"},
            {name: "#26", diameter: 0.81, color: "#F38181", awg: "26#"},
            {name: "TRIAX", diameter: 3.7084, color: "#AA96DA", awg: "TRIAX"},
            {name: "COAX", diameter: 2.54, color: "#FCBAD3", awg: "COAX"},
            {name: "1/0#", diameter: 15.8242, color: "#A8D8EA", awg: "1/0#"},
            {name: "1x 12#", diameter: 2.6, color: "#FFAAA6", awg: "12#"},
            {name: "8#", diameter: 7.2898, color: "#FF8C94", awg: "8#"},
            {name: "4#", diameter: 10.5918, color: "#C3AED6", awg: "4#"},
            {name: "2x24#", diameter: 3.124, color: "#E74C3C", awg: "24#"},
            {name: "12#", diameter: 5.0, color: "#C3AED6", awg: "12#"},
            {name: "17#", diameter: 2.0, color: "#FFD93D", awg: "17#"}
        ];

        // Vari√°veis globais
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Constantes visuais
        const NODE_RADIUS = 25;
        const NODE_COLOR = '#667eea';
        const NODE_SELECTED_COLOR = '#764ba2';
        const CONNECTION_COLOR = '#3498db';
        
        let nodes = [];
        let connections = [];
        let routes = [];
        
        let mode = 'addNode';
        let selectedNode = null;
        let connectingFrom = null;
        let nodeIdCounter = 0;
        let routeIdCounter = 0;
        let draggingNode = null;
        
        // Ajustar canvas para largura total
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.offsetWidth - 50;
            canvas.height = 500;
            redraw();
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Preencher dropdown de tipos de cabo
        function populateCableTypes() {
            const select = document.getElementById('cableType');
            cableDatabase.forEach(cable => {
                const option = document.createElement('option');
                option.value = cable.name;
                option.textContent = `${cable.name} (√ò ${cable.diameter} mm)`;
                select.appendChild(option);
            });
        }
        populateCableTypes();

        function getCableData(cableName) {
            return cableDatabase.find(c => c.name === cableName);
        }

        function setMode(newMode) {
            mode = newMode;
            
            document.getElementById('addNodeBtn').classList.remove('active');
            document.getElementById('connectBtn').classList.remove('active');
            document.getElementById('selectBtn').classList.remove('active');
            
            if (newMode === 'addNode') {
                document.getElementById('addNodeBtn').classList.add('active');
                canvas.style.cursor = 'crosshair';
            } else if (newMode === 'connect') {
                document.getElementById('connectBtn').classList.add('active');
                canvas.style.cursor = 'pointer';
            } else if (newMode === 'select') {
                document.getElementById('selectBtn').classList.add('active');
                canvas.style.cursor = 'move';
            }
            
            connectingFrom = null;
            selectedNode = null;
            redraw();
        }

        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }

        function findNodeAt(x, y) {
            for (let node of nodes) {
                const dx = node.x - x;
                const dy = node.y - y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance <= NODE_RADIUS) {
                    return node;
                }
            }
            return null;
        }

        canvas.addEventListener('click', (e) => {
            const pos = getMousePos(e);
            
            if (mode === 'addNode') {
                const name = prompt('Nome do n√≥:', `P${nodeIdCounter + 1}`);
                if (name && name.trim()) {
                    nodes.push({
                        id: nodeIdCounter++,
                        name: name.trim().toUpperCase(),
                        x: pos.x,
                        y: pos.y
                    });
                    updateNodeSelects();
                    redraw();
                }
            } else if (mode === 'connect') {
                const clickedNode = findNodeAt(pos.x, pos.y);
                
                if (clickedNode) {
                    if (!connectingFrom) {
                        connectingFrom = clickedNode;
                        redraw();
                    } else {
                        if (connectingFrom.id !== clickedNode.id) {
                            const exists = connections.some(c => 
                                (c.from === connectingFrom.name && c.to === clickedNode.name) ||
                                (c.from === clickedNode.name && c.to === connectingFrom.name)
                            );
                            
                            if (!exists) {
                                const distance = prompt('Dist√¢ncia (mm):', '1000');
                                if (distance && parseFloat(distance) > 0) {
                                    connections.push({
                                        from: connectingFrom.name,
                                        to: clickedNode.name,
                                        distance: parseFloat(distance)
                                    });
                                }
                            } else {
                                alert('Conex√£o j√° existe!');
                            }
                        }
                        connectingFrom = null;
                        redraw();
                    }
                }
            }
        });

        canvas.addEventListener('mousedown', (e) => {
            if (mode === 'select') {
                const pos = getMousePos(e);
                draggingNode = findNodeAt(pos.x, pos.y);
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (draggingNode) {
                const pos = getMousePos(e);
                draggingNode.x = pos.x;
                draggingNode.y = pos.y;
                redraw();
            }
        });

        canvas.addEventListener('mouseup', () => {
            draggingNode = null;
        });

        canvas.addEventListener('dblclick', (e) => {
            const pos = getMousePos(e);
            const clickedNode = findNodeAt(pos.x, pos.y);
            
            if (clickedNode) {
                if (confirm(`Deletar n√≥ "${clickedNode.name}"?`)) {
                    connections = connections.filter(c => 
                        c.from !== clickedNode.name && c.to !== clickedNode.name
                    );
                    nodes = nodes.filter(n => n.id !== clickedNode.id);
                    updateNodeSelects();
                    redraw();
                }
            }
        });

        function redraw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.strokeStyle = CONNECTION_COLOR;
            ctx.lineWidth = 3;
            
            connections.forEach(conn => {
                const fromNode = nodes.find(n => n.name === conn.from);
                const toNode = nodes.find(n => n.name === conn.to);
                
                if (fromNode && toNode) {
                    ctx.beginPath();
                    ctx.moveTo(fromNode.x, fromNode.y);
                    ctx.lineTo(toNode.x, toNode.y);
                    ctx.stroke();
                    
                    const midX = (fromNode.x + toNode.x) / 2;
                    const midY = (fromNode.y + toNode.y) / 2;
                    
                    ctx.fillStyle = 'white';
                    ctx.fillRect(midX - 30, midY - 12, 60, 24);
                    
                    ctx.fillStyle = CONNECTION_COLOR;
                    ctx.font = 'bold 13px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(`${conn.distance}mm`, midX, midY);
                }
            });
            
            if (connectingFrom && mode === 'connect') {
                ctx.strokeStyle = NODE_SELECTED_COLOR;
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(connectingFrom.x, connectingFrom.y);
                ctx.lineTo(canvas.width / 2, canvas.height / 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            nodes.forEach(node => {
                const isConnecting = connectingFrom && connectingFrom.id === node.id;
                
                ctx.fillStyle = isConnecting ? NODE_SELECTED_COLOR : NODE_COLOR;
                ctx.beginPath();
                ctx.arc(node.x, node.y, NODE_RADIUS, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 4;
                ctx.stroke();
                
                ctx.fillStyle = 'white';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(node.name, node.x, node.y);
            });
        }

        function updateNodeSelects() {
            const originSelect = document.getElementById('origin');
            const destSelect = document.getElementById('destination');
            
            const currentOrigin = originSelect.value;
            const currentDest = destSelect.value;
            
            originSelect.innerHTML = '<option value="">Selecione...</option>';
            destSelect.innerHTML = '<option value="">Selecione...</option>';
            
            nodes.forEach(node => {
                const option1 = document.createElement('option');
                option1.value = node.name;
                option1.textContent = node.name;
                originSelect.appendChild(option1);
                
                const option2 = document.createElement('option');
                option2.value = node.name;
                option2.textContent = node.name;
                destSelect.appendChild(option2);
            });
            
            if (currentOrigin) originSelect.value = currentOrigin;
            if (currentDest) destSelect.value = currentDest;
        }

        function clearCanvas() {
            if (nodes.length === 0) return;
            
            if (confirm('Limpar todo o canvas? Isso tamb√©m remover√° todas as rotas.')) {
                nodes = [];
                connections = [];
                routes = [];
                connectingFrom = null;
                selectedNode = null;
                nodeIdCounter = 0;
                routeIdCounter = 0;
                updateNodeSelects();
                redraw();
                updateRoutesList();
                updateResults();
                updateBundleVisualization();
            }
        }

        function findShortestPath(origin, destination) {
            const graph = {};
            
            connections.forEach(conn => {
                if (!graph[conn.from]) graph[conn.from] = [];
                if (!graph[conn.to]) graph[conn.to] = [];
                
                graph[conn.from].push({ node: conn.to, distance: conn.distance });
                graph[conn.to].push({ node: conn.from, distance: conn.distance });
            });

            if (!graph[origin]) {
                return { found: false, error: `Ponto de origem "${origin}" n√£o tem conex√µes` };
            }
            if (!graph[destination]) {
                return { found: false, error: `Ponto de destino "${destination}" n√£o tem conex√µes` };
            }

            const distances = {};
            const previous = {};
            const unvisited = new Set();

            for (const node in graph) {
                distances[node] = Infinity;
                previous[node] = null;
                unvisited.add(node);
            }
            distances[origin] = 0;

            while (unvisited.size > 0) {
                let current = null;
                let minDist = Infinity;
                for (const node of unvisited) {
                    if (distances[node] < minDist) {
                        minDist = distances[node];
                        current = node;
                    }
                }

                if (current === null || distances[current] === Infinity) break;
                if (current === destination) break;

                unvisited.delete(current);

                if (graph[current]) {
                    for (const neighbor of graph[current]) {
                        const alt = distances[current] + neighbor.distance;
                        if (alt < distances[neighbor.node]) {
                            distances[neighbor.node] = alt;
                            previous[neighbor.node] = current;
                        }
                    }
                }
            }

            if (distances[destination] === Infinity) {
                return { found: false, error: `N√£o h√° caminho entre "${origin}" e "${destination}"` };
            }

            const path = [];
            let current = destination;
            while (current !== null) {
                path.unshift(current);
                current = previous[current];
            }

            return { found: true, path: path, distance: distances[destination] };
        }

        function addRoute() {
            const cableType = document.getElementById('cableType').value;
            const quantity = parseInt(document.getElementById('quantity').value);
            const origin = document.getElementById('origin').value;
            const destination = document.getElementById('destination').value;

            if (!cableType) {
                alert('Por favor, selecione o tipo de cabo');
                return;
            }

            if (!quantity || quantity <= 0) {
                alert('Por favor, insira uma quantidade v√°lida');
                return;
            }

            if (!origin || !destination) {
                alert('Por favor, selecione origem e destino');
                return;
            }

            if (origin === destination) {
                alert('Origem e destino devem ser diferentes');
                return;
            }

            const result = findShortestPath(origin, destination);

            if (!result.found) {
                alert(result.error);
                return;
            }

            const route = {
                id: routeIdCounter++,
                cableType,
                quantity,
                points: result.path,
                totalDistance: result.distance
            };

            routes.push(route);

            document.getElementById('cableType').value = '';
            document.getElementById('quantity').value = '1';

            updateRoutesList();
            updateResults();
            updateBundleVisualization();
        }

        function removeRoute(id) {
            routes = routes.filter(r => r.id !== id);
            updateRoutesList();
            updateResults();
            updateBundleVisualization();
        }

        function updateResults() {
            const container = document.getElementById('resultsContainer');
            
            if (routes.length === 0) {
                container.innerHTML = '<div class="empty-state"><p>Adicione rotas para ver os resultados</p></div>';
                return;
            }

            const margin = parseFloat(document.getElementById('marginInput').value) / 100;
            const totals = {};

            routes.forEach(route => {
                const lengthWithMargin = route.totalDistance * (1 + margin);
                const totalLength = lengthWithMargin * route.quantity;

                if (!totals[route.cableType]) {
                    totals[route.cableType] = {
                        routes: [],
                        totalLength: 0
                    };
                }

                totals[route.cableType].routes.push({
                    path: route.points.join(' ‚Üí '),
                    quantity: route.quantity,
                    baseDistance: route.totalDistance,
                    totalLength: totalLength
                });

                totals[route.cableType].totalLength += totalLength;
            });

            let html = '';

            for (const [cableType, data] of Object.entries(totals)) {
                html += `
                    <div class="result-card">
                        <div class="result-title">${cableType}</div>
                `;

                data.routes.forEach(route => {
                    html += `
                        <div class="result-item">
                            <span style="flex: 1;">${route.path}</span>
                            <span style="font-weight: 600;">${(route.totalLength / 1000).toFixed(2)} m</span>
                        </div>
                    `;
                });

                html += `
                        <div class="result-total">
                            <span>Total:</span>
                            <span>${(data.totalLength / 1000).toFixed(2)} m</span>
                        </div>
                    </div>
                `;
            }

            container.innerHTML = html;
        }

        // Algoritmo avan√ßado de Circle Packing
        class CirclePacking {
            constructor(cables) {
                this.cables = cables;
                this.diameters = cables.map(c => c.diameter);
                this.radii = this.diameters.map(d => d / 2);
                this.n = cables.length;
            }
            
            checkOverlap(positions, containerRadius) {
                let penalty = 0;
                
                for (let i = 0; i < this.n; i++) {
                    const dist = Math.sqrt(positions[i].x ** 2 + positions[i].y ** 2);
                    const excess = (dist + this.radii[i]) - containerRadius;
                    if (excess > 0) {
                        penalty += excess ** 2 * 1000;
                    }
                }
                
                for (let i = 0; i < this.n; i++) {
                    for (let j = i + 1; j < this.n; j++) {
                        const dx = positions[i].x - positions[j].x;
                        const dy = positions[i].y - positions[j].y;
                        const dist = Math.sqrt(dx ** 2 + dy ** 2);
                        const minDist = this.radii[i] + this.radii[j];
                        const overlap = minDist - dist;
                        
                        if (overlap > 0) {
                            penalty += overlap ** 2 * 1000;
                        }
                    }
                }
                
                return penalty;
            }
            
            estimateRadius() {
                const totalArea = this.radii.reduce((sum, r) => sum + Math.PI * r ** 2, 0);
                const estimatedRadius = Math.sqrt(totalArea / Math.PI) * 1.15;
                const maxRadius = Math.max(...this.radii);
                return Math.max(estimatedRadius, maxRadius);
            }
            
            randomPositions(containerRadius) {
                const positions = [];
                const maxR = containerRadius * 0.7;
                
                for (let i = 0; i < this.n; i++) {
                    const angle = Math.random() * 2 * Math.PI;
                    const r = Math.random() * maxR;
                    positions.push({
                        x: r * Math.cos(angle),
                        y: r * Math.sin(angle)
                    });
                }
                return positions;
            }
            
            applyRepulsionForces(positions, containerRadius) {
                const forces = positions.map(() => ({x: 0, y: 0}));
                const minGap = 0.01;
                
                for (let i = 0; i < this.n; i++) {
                    for (let j = i + 1; j < this.n; j++) {
                        const dx = positions[j].x - positions[i].x;
                        const dy = positions[j].y - positions[i].y;
                        const dist = Math.sqrt(dx ** 2 + dy ** 2);
                        const minDist = this.radii[i] + this.radii[j] + minGap;
                        
                        if (dist < minDist && dist > 0.001) {
                            const overlap = minDist - dist;
                            const force = overlap / dist;
                            
                            forces[i].x -= dx * force * 0.5;
                            forces[i].y -= dy * force * 0.5;
                            forces[j].x += dx * force * 0.5;
                            forces[j].y += dy * force * 0.5;
                        }
                    }
                    
                    const distFromCenter = Math.sqrt(positions[i].x ** 2 + positions[i].y ** 2);
                    const maxDist = containerRadius - this.radii[i] - minGap;
                    
                    if (distFromCenter > maxDist && distFromCenter > 0.001) {
                        const excess = distFromCenter - maxDist;
                        const force = excess / distFromCenter;
                        
                        forces[i].x -= positions[i].x * force;
                        forces[i].y -= positions[i].y * force;
                    }
                }
                
                for (let i = 0; i < this.n; i++) {
                    positions[i].x += forces[i].x;
                    positions[i].y += forces[i].y;
                }
            }
            
            isValidSolution(positions, containerRadius) {
                const tolerance = 1e-6;
                
                for (let i = 0; i < this.n; i++) {
                    const dist = Math.sqrt(positions[i].x ** 2 + positions[i].y ** 2);
                    if (dist + this.radii[i] > containerRadius + tolerance) {
                        return false;
                    }
                }
                
                for (let i = 0; i < this.n; i++) {
                    for (let j = i + 1; j < this.n; j++) {
                        const dx = positions[i].x - positions[j].x;
                        const dy = positions[i].y - positions[j].y;
                        const dist = Math.sqrt(dx ** 2 + dy ** 2);
                        const minDist = this.radii[i] + this.radii[j];
                        
                        if (dist < minDist - tolerance) {
                            return false;
                        }
                    }
                }
                
                return true;
            }
            
            optimize(iterations = 8000) {
                let bestRadius = Infinity;
                let bestPositions = null;
                
                const trials = 15; // Reduzido para performance
                
                for (let trial = 0; trial < trials; trial++) {
                    let radius = this.estimateRadius() * 1.2;
                    let positions = this.randomPositions(radius);
                    
                    for (let iter = 0; iter < 500; iter++) {
                        this.applyRepulsionForces(positions, radius);
                        
                        if (iter % 50 === 0) {
                            const penalty = this.checkOverlap(positions, radius);
                            if (penalty < 0.001) break;
                        }
                    }
                    
                    let shrinkAttempts = 0;
                    const maxShrinkAttempts = 50;
                    
                    while (shrinkAttempts < maxShrinkAttempts) {
                        const testRadius = radius * 0.995;
                        const testPositions = positions.map(p => ({...p}));
                        
                        for (let i = 0; i < 30; i++) {
                            this.applyRepulsionForces(testPositions, testRadius);
                        }
                        
                        if (this.isValidSolution(testPositions, testRadius)) {
                            radius = testRadius;
                            positions = testPositions;
                            shrinkAttempts = 0;
                        } else {
                            shrinkAttempts++;
                        }
                    }
                    
                    for (let iter = 0; iter < 100; iter++) {
                        this.applyRepulsionForces(positions, radius);
                    }
                    
                    if (this.isValidSolution(positions, radius)) {
                        if (radius < bestRadius) {
                            bestRadius = radius;
                            bestPositions = positions.map(p => ({...p}));
                        }
                    }
                }
                
                if (bestPositions === null) {
                    bestRadius = this.estimateRadius() * 1.5;
                    bestPositions = this.randomPositions(bestRadius);
                    
                    for (let iter = 0; iter < 1000; iter++) {
                        this.applyRepulsionForces(bestPositions, bestRadius);
                    }
                    
                    while (!this.isValidSolution(bestPositions, bestRadius)) {
                        bestRadius *= 1.05;
                        for (let iter = 0; iter < 50; iter++) {
                            this.applyRepulsionForces(bestPositions, bestRadius);
                        }
                    }
                }
                
                return {
                    radius: bestRadius,
                    diameter: bestRadius * 2,
                    positions: bestPositions
                };
            }
        }

        // Fun√ß√£o para calcular wire bundle usando algoritmo avan√ßado
        function calculateWireBundle(wires) {
            if (wires.length === 0) return { diameter: 0, circles: [] };
            
            if (wires.length === 1) {
                return {
                    diameter: wires[0].diameter,
                    circles: [{
                        x: 0, 
                        y: 0, 
                        r: wires[0].diameter / 2, 
                        color: wires[0].color, 
                        name: wires[0].name
                    }]
                };
            }

            // Usar algoritmo avan√ßado
            const packing = new CirclePacking(wires);
            const result = packing.optimize();
            
            // Converter posi√ß√µes para formato de c√≠rculos
            const circles = result.positions.map((pos, i) => ({
                x: pos.x,
                y: pos.y,
                r: wires[i].diameter / 2,
                color: wires[i].color,
                name: wires[i].name
            }));

            return {
                diameter: result.diameter,
                circles: circles
            };
        }

        function drawWireBundle(canvas, bundleData) {
            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // Escala para caber no canvas
            const scale = Math.min(canvas.width, canvas.height) / (bundleData.diameter * 1.2);
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Desenhar c√≠rculo externo
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.arc(centerX, centerY, (bundleData.diameter / 2) * scale, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Desenhar cada fio
            bundleData.circles.forEach(circle => {
                ctx.fillStyle = circle.color;
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(
                    centerX + circle.x * scale,
                    centerY + circle.y * scale,
                    circle.r * scale,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                ctx.stroke();
                
                // Texto
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(
                    circle.name,
                    centerX + circle.x * scale,
                    centerY + circle.y * scale
                );
            });
        }

        function updateBundleVisualization() {
            const container = document.getElementById('bundleContainer');
            
            if (routes.length === 0) {
                container.innerHTML = '<div class="empty-state"><p>Adicione rotas para ver os wire bundles</p></div>';
                return;
            }

            // Mapear vias por segmento
            const branchMap = {};

            routes.forEach(route => {
                for (let i = 0; i < route.points.length - 1; i++) {
                    const from = route.points[i];
                    const to = route.points[i + 1];
                    const segmentKey = [from, to].sort().join(' ‚Üî ');

                    if (!branchMap[segmentKey]) {
                        branchMap[segmentKey] = [];
                    }

                    const cableData = getCableData(route.cableType);
                    if (cableData) {
                        for (let j = 0; j < route.quantity; j++) {
                            branchMap[segmentKey].push({
                                name: route.cableType,
                                diameter: cableData.diameter,
                                color: cableData.color
                            });
                        }
                    }
                }
            });

            let html = '';

            for (const [segment, wires] of Object.entries(branchMap)) {
                const bundleData = calculateWireBundle(wires);
                const canvasId = `bundle-${segment.replace(/[^a-zA-Z0-9]/g, '')}`;
                
                html += `
                    <div class="bundle-item">
                        <div class="bundle-header">
                            <span>${segment}</span>
                            <span class="bundle-diameter">√ò ${bundleData.diameter.toFixed(2)} mm</span>
                        </div>
                        <div class="bundle-content">
                            <div class="bundle-visual">
                                <canvas id="${canvasId}" class="bundle-canvas" width="200" height="200"></canvas>
                            </div>
                            <div class="bundle-details">
                                <strong style="display: block; margin-bottom: 10px;">Cabos nesta ramifica√ß√£o:</strong>
                `;

                // Agrupar por tipo
                const wireGroups = {};
                wires.forEach(wire => {
                    if (!wireGroups[wire.name]) {
                        wireGroups[wire.name] = { count: 0, color: wire.color, diameter: wire.diameter };
                    }
                    wireGroups[wire.name].count++;
                });

                for (const [name, data] of Object.entries(wireGroups)) {
                    html += `
                        <div class="wire-list-item">
                            <div class="wire-color-dot" style="background-color: ${data.color};"></div>
                            <span><strong>${data.count}√ó</strong> ${name} (√ò ${data.diameter} mm)</span>
                        </div>
                    `;
                }

                html += `
                            </div>
                        </div>
                    </div>
                `;
            }

            container.innerHTML = html;

            // Desenhar os bundles
            setTimeout(() => {
                for (const [segment, wires] of Object.entries(branchMap)) {
                    const canvasId = `bundle-${segment.replace(/[^a-zA-Z0-9]/g, '')}`;
                    const canvas = document.getElementById(canvasId);
                    if (canvas) {
                        const bundleData = calculateWireBundle(wires);
                        drawWireBundle(canvas, bundleData);
                    }
                }
            }, 100);
        }

        function exportResults() {
            if (routes.length === 0) {
                alert('Adicione rotas antes de exportar');
                return;
            }

            const margin = parseFloat(document.getElementById('marginInput').value) / 100;
            
            let csv = 'RESULTADOS POR ROTA\n';
            csv += 'Tipo de Cabo,Origem,Destino,Caminho Completo,Dist√¢ncia Base (mm),Quantidade Vias,Total com Margem (m)\n';

            routes.forEach(route => {
                const path = route.points.join(' ‚Üí ');
                const origin = route.points[0];
                const destination = route.points[route.points.length - 1];
                const lengthWithMargin = route.totalDistance * (1 + margin);
                const totalLength = lengthWithMargin * route.quantity;
                csv += `${route.cableType},${origin},${destination},"${path}",${route.totalDistance},${route.quantity},${(totalLength / 1000).toFixed(2)}\n`;
            });

            csv += '\n\nRESUMO POR TIPO DE CABO\n';
            csv += 'Tipo de Cabo,Comprimento Total (m)\n';

            const totals = {};
            routes.forEach(route => {
                const lengthWithMargin = route.totalDistance * (1 + margin);
                const totalLength = lengthWithMargin * route.quantity;

                if (!totals[route.cableType]) {
                    totals[route.cableType] = 0;
                }
                totals[route.cableType] += totalLength;
            });

            for (const [cableType, length] of Object.entries(totals)) {
                csv += `${cableType},${(length / 1000).toFixed(2)}\n`;
            }

            csv += '\n\nWIRE BUNDLE POR RAMIFICA√á√ÉO\n';
            csv += 'Segmento,Tipo de Cabo,Quantidade de Vias,Di√¢metro Bundle (mm)\n';

            const branchMap = {};
            routes.forEach(route => {
                for (let i = 0; i < route.points.length - 1; i++) {
                    const from = route.points[i];
                    const to = route.points[i + 1];
                    const segmentKey = `${from} ‚Üî ${to}`;

                    if (!branchMap[segmentKey]) {
                        branchMap[segmentKey] = [];
                    }

                    const cableData = getCableData(route.cableType);
                    if (cableData) {
                        for (let j = 0; j < route.quantity; j++) {
                            branchMap[segmentKey].push({
                                name: route.cableType,
                                diameter: cableData.diameter,
                                color: cableData.color
                            });
                        }
                    }
                }
            });

            for (const [segment, wires] of Object.entries(branchMap)) {
                const bundleData = calculateWireBundle(wires);
                
                const wireGroups = {};
                wires.forEach(wire => {
                    if (!wireGroups[wire.name]) {
                        wireGroups[wire.name] = 0;
                    }
                    wireGroups[wire.name]++;
                });

                for (const [name, count] of Object.entries(wireGroups)) {
                    csv += `${segment},${name},${count},${bundleData.diameter.toFixed(2)}\n`;
                }
            }

            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'wire_bundle_completo.csv';
            link.click();
        }

        function clearAll() {
            if (routes.length === 0) return;
            
            if (confirm('Limpar todas as rotas?')) {
                routes = [];
                routeIdCounter = 0;
                updateRoutesList();
                updateResults();
                updateBundleVisualization();
            }
        }

        document.getElementById('marginInput').addEventListener('input', function() {
            if (routes.length > 0) {
                updateResults();
            }
        });

        async function exportToVisio() {
            if (nodes.length === 0) {
                alert('Desenhe o diagrama no canvas antes de exportar!');
                return;
            }

            // Preparar dados
            const exportData = {
                nodes: nodes.map(n => ({
                    name: n.name,
                    x: n.x,
                    y: n.y
                })),
                connections: connections.map(c => ({
                    from: c.from,
                    to: c.to,
                    distance: c.distance
                }))
            };

            // Usar biblioteca JSZip para criar arquivo VSDX v√°lido
            const zip = new JSZip();
            
            // Estrutura de arquivos VSDX corrigida
            zip.file('[Content_Types].xml', createContentTypes());
            
            const relsFolder = zip.folder('_rels');
            relsFolder.file('.rels', createRootRels());
            
            const visioFolder = zip.folder('visio');
            visioFolder.file('document.xml', createDocument());
            
            const visioRelsFolder = visioFolder.folder('_rels');
            visioRelsFolder.file('document.xml.rels', createDocumentRels());
            
            const pagesFolder = visioFolder.folder('pages');
            pagesFolder.file('pages.xml', createPages());
            pagesFolder.file('page1.xml', createPage1(exportData));
            
            const pagesRelsFolder = pagesFolder.folder('_rels');
            pagesRelsFolder.file('pages.xml.rels', createPagesRels());
            pagesRelsFolder.file('page1.xml.rels', createPage1Rels());
            
            // Gerar arquivo
            const blob = await zip.generateAsync({
                type: 'blob',
                compression: 'DEFLATE',
                compressionOptions: {
                    level: 6
                }
            });
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'cable_diagram.vsdx';
            link.click();
        }

        function createContentTypes() {
            return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
    <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
    <Default Extension="xml" ContentType="application/xml"/>
    <Override PartName="/visio/document.xml" ContentType="application/vnd.ms-visio.drawing.main+xml"/>
    <Override PartName="/visio/pages/pages.xml" ContentType="application/vnd.ms-visio.pages+xml"/>
    <Override PartName="/visio/pages/page1.xml" ContentType="application/vnd.ms-visio.page+xml"/>
</Types>`;
        }

        function createRootRels() {
            return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
    <Relationship Id="rId1" Type="http://schemas.microsoft.com/visio/2010/relationships/document" Target="visio/document.xml"/>
</Relationships>`;
        }

        function createDocument() {
            return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<VisioDocument xmlns="http://schemas.microsoft.com/office/visio/2012/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xml:space="preserve">
    <DocumentSettings DefaultTabStop="0.5" DefaultTextStyle="3" DefaultLineStyle="3" DefaultFillStyle="3"/>
    <Colors>
        <ColorEntry IX="0" RGB="#000000"/>
        <ColorEntry IX="1" RGB="#FFFFFF"/>
        <ColorEntry IX="2" RGB="#FF0000"/>
        <ColorEntry IX="3" RGB="#00FF00"/>
        <ColorEntry IX="4" RGB="#0000FF"/>
        <ColorEntry IX="5" RGB="#FFFF00"/>
        <ColorEntry IX="6" RGB="#FF00FF"/>
        <ColorEntry IX="7" RGB="#00FFFF"/>
    </Colors>
    <FaceNames>
        <FaceName ID="0" Name="Segoe UI" UnicodeRanges="0 1 2 3 4 5" CharSets="0 0 0 0 0 0" Panos="2 11 5 2 4 2 4 2 2 3" Flags="325"/>
    </FaceNames>
</VisioDocument>`;
        }

        function createDocumentRels() {
            return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
    <Relationship Id="rId1" Type="http://schemas.microsoft.com/visio/2010/relationships/pages" Target="pages/pages.xml"/>
</Relationships>`;
        }

        function createPagesRels() {
            return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
    <Relationship Id="rId1" Type="http://schemas.microsoft.com/visio/2010/relationships/page" Target="page1.xml"/>
</Relationships>`;
        }

        function createPages() {
            return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Pages xmlns="http://schemas.microsoft.com/office/visio/2012/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xml:space="preserve">
    <Page ID="0" NameU="Page-1" Name="Cable Diagram" ViewScale="1" ViewCenterX="5.5" ViewCenterY="4.25">
        <PageSheet LineStyle="0" FillStyle="0" TextStyle="0">
            <Cell N="PageWidth" V="11" U="IN"/>
            <Cell N="PageHeight" V="8.5" U="IN"/>
            <Cell N="ShdwOffsetX" V="0.125" U="IN"/>
            <Cell N="ShdwOffsetY" V="-0.125" U="IN"/>
            <Cell N="PageScale" V="1" U="IN_F"/>
            <Cell N="DrawingScale" V="1" U="IN_F"/>
            <Cell N="DrawingSizeType" V="1"/>
            <Cell N="DrawingScaleType" V="0"/>
            <Cell N="InhibitSnap" V="0"/>
            <Cell N="PageLockReplace" V="0" U="BOOL"/>
            <Cell N="PageLockDuplicate" V="0" U="BOOL"/>
            <Cell N="UIVisibility" V="0"/>
            <Cell N="ShdwType" V="0"/>
            <Cell N="ShdwObliqueAngle" V="0"/>
            <Cell N="ShdwScaleFactor" V="1"/>
            <Section N="User">
                <Row N="msvStructureType">
                    <Cell N="Value" V="0"/>
                    <Cell N="Prompt" V=""/>
                </Row>
            </Section>
        </PageSheet>
        <Rel r:id="rId1"/>
    </Page>
</Pages>`;
        }

        function createPage1Rels() {
            return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
</Relationships>`;
        }

        function createPage1(data) {
            const scale = 0.015;
            let shapesXML = '';
            let shapeId = 1;
            
            // Criar shapes para n√≥s
            data.nodes.forEach(node => {
                const x = node.x * scale + 2;
                const y = 8.5 - (node.y * scale + 2);
                
                shapesXML += `
        <Shape ID="${shapeId}" Type="Shape" LineStyle="3" FillStyle="3" TextStyle="3">
            <Cell N="PinX" V="${x}" U="IN"/>
            <Cell N="PinY" V="${y}" U="IN"/>
            <Cell N="Width" V="0.5" U="IN"/>
            <Cell N="Height" V="0.5" U="IN"/>
            <Cell N="LocPinX" V="0.25" U="IN"/>
            <Cell N="LocPinY" V="0.25" U="IN"/>
            <Cell N="Angle" V="0"/>
            <Cell N="FlipX" V="0"/>
            <Cell N="FlipY" V="0"/>
            <Cell N="ResizeMode" V="0"/>
            <Section N="Character">
                <Row IX="0">
                    <Cell N="Font" V="Segoe UI"/>
                    <Cell N="Color" V="1"/>
                    <Cell N="Style" V="0"/>
                    <Cell N="Case" V="0"/>
                    <Cell N="Pos" V="0"/>
                    <Cell N="FontScale" V="1"/>
                    <Cell N="Size" V="0.1389" U="PT"/>
                    <Cell N="DblUnderline" V="0"/>
                    <Cell N="Overline" V="0"/>
                    <Cell N="Strikethru" V="0"/>
                    <Cell N="DoubleStrikethrough" V="0"/>
                    <Cell N="Letterspace" V="0"/>
                    <Cell N="ColorTrans" V="0"/>
                </Row>
            </Section>
            <Section N="Paragraph">
                <Row IX="0">
                    <Cell N="IndFirst" V="0" U="IN"/>
                    <Cell N="IndLeft" V="0" U="IN"/>
                    <Cell N="IndRight" V="0" U="IN"/>
                    <Cell N="SpLine" V="-1.2" U="PT"/>
                    <Cell N="SpBefore" V="0" U="PT"/>
                    <Cell N="SpAfter" V="0" U="PT"/>
                    <Cell N="HorzAlign" V="1"/>
                    <Cell N="Bullet" V="0"/>
                    <Cell N="BulletStr" V=""/>
                    <Cell N="BulletFont" V="0"/>
                    <Cell N="BulletFontSize" V="-1" U="PT"/>
                    <Cell N="TextPosAfterBullet" V="0" U="IN"/>
                    <Cell N="Flags" V="0"/>
                </Row>
            </Section>
            <Text>${node.name}</Text>
            <Section N="Geometry" IX="0">
                <Cell N="NoFill" V="0"/>
                <Cell N="NoLine" V="0"/>
                <Cell N="NoShow" V="0"/>
                <Cell N="NoSnap" V="0"/>
                <Row T="Ellipse" IX="1">
                    <Cell N="X" V="0.25" U="IN"/>
                    <Cell N="Y" V="0.25" U="IN"/>
                    <Cell N="A" V="0.5" U="IN"/>
                    <Cell N="B" V="0" U="IN"/>
                    <Cell N="C" V="0.25" U="IN"/>
                    <Cell N="D" V="0.25" U="IN"/>
                </Row>
            </Section>
            <Section N="Fill">
                <Cell N="FillForegnd" V="4"/>
                <Cell N="FillBkgnd" V="1"/>
                <Cell N="FillPattern" V="1"/>
                <Cell N="ShdwForegnd" V="0"/>
                <Cell N="ShdwBkgnd" V="1"/>
                <Cell N="ShdwPattern" V="0"/>
                <Cell N="FillForegndTrans" V="0"/>
                <Cell N="FillBkgndTrans" V="0"/>
                <Cell N="ShdwForegndTrans" V="0"/>
            </Section>
            <Section N="Line">
                <Cell N="LineWeight" V="0.01" U="IN"/>
                <Cell N="LineColor" V="1"/>
                <Cell N="LinePattern" V="1"/>
                <Cell N="Rounding" V="0" U="IN"/>
                <Cell N="EndArrowSize" V="2"/>
                <Cell N="BeginArrow" V="0"/>
                <Cell N="EndArrow" V="0"/>
                <Cell N="LineCap" V="0"/>
                <Cell N="BeginArrowSize" V="2"/>
                <Cell N="LineColorTrans" V="0"/>
            </Section>
        </Shape>`;
                shapeId++;
            });
            
            // Criar shapes para conex√µes
            data.connections.forEach(conn => {
                const fromNode = data.nodes.find(n => n.name === conn.from);
                const toNode = data.nodes.find(n => n.name === conn.to);
                
                if (fromNode && toNode) {
                    const x1 = fromNode.x * scale + 2;
                    const y1 = 8.5 - (fromNode.y * scale + 2);
                    const x2 = toNode.x * scale + 2;
                    const y2 = 8.5 - (toNode.y * scale + 2);
                    const width = Math.abs(x2 - x1);
                    const height = Math.abs(y2 - y1);
                    const pinX = Math.min(x1, x2) + width / 2;
                    const pinY = Math.min(y1, y2) + height / 2;
                    const locPinX = width / 2;
                    const locPinY = height / 2;
                    
                    shapesXML += `
        <Shape ID="${shapeId}" Type="Shape" LineStyle="3" FillStyle="3" TextStyle="3">
            <Cell N="PinX" V="${pinX}" U="IN"/>
            <Cell N="PinY" V="${pinY}" U="IN"/>
            <Cell N="Width" V="${width}" U="IN"/>
            <Cell N="Height" V="${height}" U="IN"/>
            <Cell N="LocPinX" V="${locPinX}" U="IN"/>
            <Cell N="LocPinY" V="${locPinY}" U="IN"/>
            <Cell N="Angle" V="0"/>
            <Cell N="FlipX" V="0"/>
            <Cell N="FlipY" V="0"/>
            <Section N="Character">
                <Row IX="0">
                    <Cell N="Font" V="Segoe UI"/>
                    <Cell N="Color" V="0"/>
                    <Cell N="Size" V="0.125" U="PT"/>
                </Row>
            </Section>
            <Text>${conn.distance} mm</Text>
            <Section N="Geometry" IX="0">
                <Cell N="NoFill" V="1"/>
                <Cell N="NoLine" V="0"/>
                <Cell N="NoShow" V="0"/>
                <Cell N="NoSnap" V="0"/>
                <Row T="MoveTo" IX="1">
                    <Cell N="X" V="${x1 - pinX + locPinX}" U="IN"/>
                    <Cell N="Y" V="${y1 - pinY + locPinY}" U="IN"/>
                </Row>
                <Row T="LineTo" IX="2">
                    <Cell N="X" V="${x2 - pinX + locPinX}" U="IN"/>
                    <Cell N="Y" V="${y2 - pinY + locPinY}" U="IN"/>
                </Row>
            </Section>
            <Section N="Line">
                <Cell N="LineWeight" V="0.02" U="IN"/>
                <Cell N="LineColor" V="2"/>
                <Cell N="LinePattern" V="1"/>
            </Section>
        </Shape>`;
                    shapeId++;
                }
            });
            
            return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<PageContents xmlns="http://schemas.microsoft.com/office/visio/2012/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xml:space="preserve">
    <Shapes>
${shapesXML}
    </Shapes>
    <Connects/>
</PageContents>`;
        }

        // Vari√°vel para controlar edi√ß√£o
        let editingRouteId = null;

        function saveProject() {
            if (nodes.length === 0) {
                alert('Desenhe o diagrama antes de salvar o projeto!');
                return;
            }

            const project = {
                version: '1.0',
                timestamp: new Date().toISOString(),
                nodes: nodes,
                connections: connections,
                routes: routes,
                nodeIdCounter: nodeIdCounter,
                routeIdCounter: routeIdCounter
            };

            const json = JSON.stringify(project, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `cable_project_${Date.now()}.json`;
            link.click();

            alert('Projeto salvo com sucesso!');
        }

        function loadProject(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const project = JSON.parse(e.target.result);

                    // Validar estrutura
                    if (!project.nodes || !project.connections) {
                        alert('Arquivo de projeto inv√°lido!');
                        return;
                    }

                    // Carregar dados
                    nodes = project.nodes || [];
                    connections = project.connections || [];
                    routes = project.routes || [];
                    nodeIdCounter = project.nodeIdCounter || 0;
                    routeIdCounter = project.routeIdCounter || 0;

                    // Atualizar interface
                    updateNodeSelects();
                    redraw();
                    updateRoutesList();
                    updateResults();
                    updateBundleVisualization();

                    alert('Projeto carregado com sucesso!');
                } catch (error) {
                    alert('Erro ao carregar projeto: ' + error.message);
                }
            };
            reader.readAsText(file);

            // Limpar input para permitir reload do mesmo arquivo
            event.target.value = '';
        }

        function editRoute(id) {
            const route = routes.find(r => r.id === id);
            if (!route) return;

            editingRouteId = id;

            // Preencher modal
            populateEditCableTypes();
            populateEditNodeSelects();

            document.getElementById('editCableType').value = route.cableType;
            document.getElementById('editQuantity').value = route.quantity;
            document.getElementById('editOrigin').value = route.points[0];
            document.getElementById('editDestination').value = route.points[route.points.length - 1];

            // Mostrar modal
            document.getElementById('editModal').style.display = 'block';
        }

        function populateEditCableTypes() {
            const select = document.getElementById('editCableType');
            select.innerHTML = '<option value="">Selecione...</option>';
            cableDatabase.forEach(cable => {
                const option = document.createElement('option');
                option.value = cable.name;
                option.textContent = `${cable.name} (√ò ${cable.diameter} mm)`;
                select.appendChild(option);
            });
        }

        function populateEditNodeSelects() {
            const originSelect = document.getElementById('editOrigin');
            const destSelect = document.getElementById('editDestination');

            originSelect.innerHTML = '<option value="">Selecione...</option>';
            destSelect.innerHTML = '<option value="">Selecione...</option>';

            nodes.forEach(node => {
                const option1 = document.createElement('option');
                option1.value = node.name;
                option1.textContent = node.name;
                originSelect.appendChild(option1);

                const option2 = document.createElement('option');
                option2.value = node.name;
                option2.textContent = node.name;
                destSelect.appendChild(option2);
            });
        }

        function closeEditModal() {
            document.getElementById('editModal').style.display = 'none';
            editingRouteId = null;
        }

        function saveEditedRoute() {
            if (editingRouteId === null) return;

            const cableType = document.getElementById('editCableType').value;
            const quantity = parseInt(document.getElementById('editQuantity').value);
            const origin = document.getElementById('editOrigin').value;
            const destination = document.getElementById('editDestination').value;

            if (!cableType || !quantity || !origin || !destination) {
                alert('Preencha todos os campos!');
                return;
            }

            if (origin === destination) {
                alert('Origem e destino devem ser diferentes');
                return;
            }

            // Calcular novo caminho
            const result = findShortestPath(origin, destination);

            if (!result.found) {
                alert(result.error);
                return;
            }

            // Atualizar rota
            const routeIndex = routes.findIndex(r => r.id === editingRouteId);
            if (routeIndex !== -1) {
                routes[routeIndex] = {
                    id: editingRouteId,
                    cableType: cableType,
                    quantity: quantity,
                    points: result.path,
                    totalDistance: result.distance
                };
            }

            closeEditModal();
            updateRoutesList();
            updateResults();
            updateBundleVisualization();
        }

        // Fechar modal ao clicar fora
        window.onclick = function(event) {
            const modal = document.getElementById('editModal');
            if (event.target == modal) {
                closeEditModal();
            }
        }

        function updateRoutesList() {
            const container = document.getElementById('routesList');
            
            if (routes.length === 0) {
                container.innerHTML = '<div class="empty-state"><p>Nenhuma rota definida</p></div>';
                return;
            }

            let html = '';
            routes.forEach(route => {
                const pathDisplay = route.points.join(' ‚Üí ');
                html += `
                    <div class="route-item">
                        <div class="route-header">
                            <div>
                                <span>${route.cableType}</span>
                                <span class="auto-route-badge">AUTO</span>
                            </div>
                            <div>
                                <button class="edit-btn" onclick="editRoute(${route.id})">‚úèÔ∏è Editar</button>
                                <button class="btn btn-danger" style="padding: 5px 10px; font-size: 0.8em;" onclick="removeRoute(${route.id})">‚úï</button>
                            </div>
                        </div>
                        <div class="route-info">
                            <strong>Vias:</strong> ${route.quantity}<br>
                            <strong>Caminho:</strong>
                            <div class="path-display">${pathDisplay}</div>
                            <strong>Dist√¢ncia:</strong> ${route.totalDistance} mm
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        setMode('addNode');
        redraw();
    </script>
    
    <!-- JSZip Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</body>
</html>
